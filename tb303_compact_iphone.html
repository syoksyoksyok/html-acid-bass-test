<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Web TB-303 – Compact iPhone v2</title>
  <style>
    :root{
      --bg:#e0e0e0;--panel:#cfcfcf;--line:#b6b6b6;--fg:#222;
      --led-off:#444;--led-accent:#ff6a00;--led-note:#ffd700;--led-play:#21c55d;
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color: transparent;}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:system-ui, -apple-system, "Helvetica Neue", Arial;}
    body{display:flex;justify-content:center;align-items:flex-start;min-height:100vh;padding:4px;}
    .synth{
      width:100%;max-width:390px;background:var(--panel);
      border:1px solid var(--line);border-radius:16px;padding:6px;
      box-shadow:0 6px 18px rgba(0,0,0,.15);
    }
    h1{font-size:15px;text-align:center;margin:0 0 6px 0}
    /* ====== Controls (2 columns on iPhone) ====== */
    .controls{
      display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:5px;
      padding:5px;border-radius:12px;background:#d9d9d9;border:1px solid var(--line);
    }
    .ctrl{display:flex;flex-direction:column;align-items:center;gap:2px;}
    .ctrl label{font-size:9px;font-weight:700;letter-spacing:.2px;text-transform:uppercase}
    .value-display{font-size:7px;font-weight:700;color:#0f0;font-family:ui-monospace,monospace;background:#2b2b2b;padding:1px 3px;border-radius:3px;min-width:32px;text-align:center;border:1px solid #333}
    /* Knob-like ranges set to 1/3 original (≈56px → 18.7px) -> use 20px */
    input[type="range"].knob{
      -webkit-appearance:none;appearance:none;width:20px;height:20px;border-radius:50%;
      background:#2b2b2b;border:2px solid #3f3f3f;position:relative;
      box-shadow:inset 0 0 0 1px #0003, 1px 1px 2px #fff9, -1px -1px 2px #0006;
      touch-action:none;
      transform-origin:center center;
    }
    input[type="range"].knob::-webkit-slider-thumb{ -webkit-appearance:none; width:0; height:0;}
    input[type="range"].knob::before{
      content:""; position:absolute; left:50%; top:3px; transform:translateX(-50%);
      width:2px; height:6px; border-radius:2px; background:#eee;
    }
    /* Waveform switch button */
    .switch{padding:4px 8px;border:1px solid var(--line);border-radius:8px;background:#bbb;font-weight:700;font-size:11px}
    .transport{
      display:grid;grid-template-columns:1fr 1fr;gap:5px;margin-top:5px;align-items:center;
    }
    .transport .row{grid-column:span 2;display:flex;gap:5px;justify-content:space-between;align-items:center}
    .btn{
      padding:6px 8px;border-radius:8px;border:1px solid var(--line);background:#bdbdbd;font-weight:700;font-size:12px;
    }
    #play-stop.playing{background:var(--led-play);color:#fff}
    .lcd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas; font-size:12px;
      background:#333;color:#0f0;border-radius:6px;padding:3px 5px;min-width:36px;text-align:center}
    /* Sequencer: optimized compact size */
    .seq{display:grid;grid-template-columns:repeat(8,1fr);gap:1px;margin:5px 0;}
    .step{
      display:flex;flex-direction:column;align-items:center;gap:0.5px;
      padding:1px;border-radius:3px;background:#d9d9d9;border:1px solid var(--line);
      transition:background 0.1s ease;
    }
    .step.playing{background:#b8e6d5;border-color:var(--led-play)}
    .led{width:8px;height:8px;border-radius:50%;background:var(--led-off);border:1.5px solid #222;box-shadow:inset 0 0 3px rgba(0,0,0,.45);transition:all 0.1s ease;}
    .led.active{background:var(--led-note)}
    .led.active.accent{background:var(--led-accent)}
    .led.playing{
      background:var(--led-play) !important;
      border-color:var(--led-play);
      box-shadow:0 0 8px 2px var(--led-play), inset 0 0 4px rgba(255,255,255,.6);
      transform:scale(1.2);
    }
    .note-controls{display:flex;gap:0.5px}
    .note-controls button{width:10px;height:10px;line-height:10px;font-size:7px;padding:0;border-radius:2px;border:1px solid #999;background:#bdbdbd}
    .note-controls button.active{background:var(--led-accent);color:#fff;border-color:#f90}
    .note-controls button:nth-child(4).active{background:var(--led-note);color:#000;border-color:#fc0}
    .help{font-size:10px;color:#3339;text-align:center;margin:4px 0 0 0}
    /* Visualizers */
    .visualizers{display:grid;grid-template-columns:1fr 1fr;gap:4px;margin:4px 0}
    .visualizer{background:#2b2b2b;border-radius:6px;border:1px solid #333;padding:3px;position:relative}
    .visualizer canvas{width:100%;height:35px;display:block;image-rendering:crisp-edges}
    .vis-label{font-size:7px;color:#0f0;text-align:center;font-family:monospace;margin-top:2px;font-weight:700}
    /* Extreme small screens */
    @media (max-width:380px){
      .synth{max-width:350px;padding:5px}
      .controls{padding:4px;gap:4px}
      .seq{gap:0.5px}
    }
  </style>
</head>
<body>
  <div class="synth" id="app">
    <h1>Web TB-303 (Compact v2 - Refactored)</h1>

    <div class="controls">
      <div class="ctrl">
        <label>Wave</label>
        <button id="waveform" class="switch">SAW</button>
      </div>
      <div class="ctrl">
        <label>Cutoff</label>
        <input id="cutoff" class="knob" type="range" min="100" max="8000" value="800" step="1">
      </div>
      <div class="ctrl">
        <label>Res</label>
        <input id="resonance" class="knob" type="range" min="0" max="30" value="5" step="0.1">
      </div>
      <div class="ctrl">
        <label>Env</label>
        <input id="envMod" class="knob" type="range" min="0" max="5000" value="2000" step="1">
      </div>
      <div class="ctrl">
        <label>Decay</label>
        <input id="decay" class="knob" type="range" min="0.05" max="1.0" value="0.3" step="0.01">
      </div>
    </div>

    <div class="visualizers">
      <div class="visualizer">
        <canvas id="filter-canvas" width="180" height="35"></canvas>
        <div class="vis-label">FILTER</div>
      </div>
      <div class="visualizer">
        <canvas id="envelope-canvas" width="180" height="35"></canvas>
        <div class="vis-label">ENVELOPE</div>
      </div>
    </div>

    <div class="seq" id="sequencer"></div>

    <div class="transport">
      <button id="play-stop" class="btn">Play</button>
      <button id="randomize" class="btn">Randomize</button>
      <div class="row">
        <div style="display:flex;align-items:center;gap:6px;flex:1;">
          <span style="font-size:11px;font-weight:700">BPM</span>
          <input id="bpm" type="range" min="60" max="180" value="128" step="1" style="flex:1">
          <span id="bpm-display" class="lcd">128</span>
        </div>
        <div style="display:flex;align-items:center;gap:6px;flex:1;">
          <span style="font-size:11px;font-weight:700">LEN</span>
          <input id="length" type="range" min="1" max="16" value="16" step="1" style="flex:1">
          <span id="length-display" class="lcd">16</span>
        </div>
      </div>
    </div>

    <p class="help">リファクタリング済み：クラスベース設計、改善されたコード構造</p>
  </div>

  <script>
    'use strict';

    // ============================================================
    // Constants
    // ============================================================
    const CONSTANTS = {
      MAX_STEPS: 16,
      BASE_NOTE: 36,
      SCHEDULE_AHEAD_TIME: 0.1,
      SCHEDULER_INTERVAL: 25,
      SIXTEENTH_NOTE_MULTIPLIER: 0.25,
      SCALE: [0, 2, 3, 5, 7, 8, 10],
      NOTE_PROBABILITY: 0.4,
      OCTAVE_UP_PROBABILITY: 0.7,
      ACCENT_PROBABILITY: 0.15,
      SLIDE_PROBABILITY: 0.1,
      ACCENT_GAIN_MULTIPLIER: 1.5,
      NORMAL_GAIN: 0.7,
      ACCENT_GAIN: 1.0,
      KNOB_ROTATION_MIN: -135,
      KNOB_ROTATION_RANGE: 270,
      DRAG_SENSITIVITY_NORMAL: 0.5,
      DRAG_SENSITIVITY_FINE: 0.1,
      PITCH_MAX: 48,
      FILTER_ENV_DECAY_MULTIPLIER: 1.2,
      VCA_RELEASE: 0.05,
      OSC_STOP_OFFSET: 0.1,
      SLIDE_TIME: 0.05
    };

    // ============================================================
    // AudioEngine: Handles all audio synthesis
    // ============================================================
    class AudioEngine {
      constructor() {
        this.audioContext = null;
      }

      initialize() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
      }

      getContext() {
        return this.audioContext;
      }

      midiToFrequency(midiNote) {
        return Math.pow(2, (midiNote - 69) / 12) * 440;
      }

      createOscillator(waveType, frequency, time) {
        const osc = this.audioContext.createOscillator();
        osc.type = waveType === 'SAW' ? 'sawtooth' : 'square';
        osc.frequency.setValueAtTime(frequency, time);
        return osc;
      }

      createFilter(cutoff, resonance, time) {
        const filter = this.audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(cutoff, time);
        filter.Q.setValueAtTime(resonance, time);
        return filter;
      }

      createEnvelope(attackValue, decayTime, time) {
        const env = this.audioContext.createGain();
        env.gain.setValueAtTime(attackValue, time);
        env.gain.linearRampToValueAtTime(0, time + decayTime);
        return env;
      }

      applySlide(osc, prevFreq, targetFreq, time) {
        osc.frequency.setValueAtTime(prevFreq, time);
        osc.frequency.linearRampToValueAtTime(targetFreq, time + CONSTANTS.SLIDE_TIME);
      }

      playNote(note, settings, time, slideInfo = null) {
        if (!note.active) return;

        const pitch = CONSTANTS.BASE_NOTE + note.octave * 12 + note.pitch;
        const frequency = this.midiToFrequency(pitch);

        // Create audio nodes
        const osc = this.createOscillator(settings.waveform, frequency, time);
        const filter = this.createFilter(settings.cutoff, settings.resonance, time);
        const vca = this.audioContext.createGain();

        // Apply envelope modulation to filter
        const envMod = note.accent
          ? settings.envMod * CONSTANTS.ACCENT_GAIN_MULTIPLIER
          : settings.envMod;

        const filterEnv = this.createEnvelope(
          envMod,
          settings.decay * CONSTANTS.FILTER_ENV_DECAY_MULTIPLIER,
          time
        );
        filterEnv.connect(filter.frequency);

        // Apply VCA envelope
        const gain = note.accent ? CONSTANTS.ACCENT_GAIN : CONSTANTS.NORMAL_GAIN;
        vca.gain.setValueAtTime(gain, time);
        vca.gain.linearRampToValueAtTime(0, time + settings.decay + CONSTANTS.VCA_RELEASE);

        // Apply slide if needed
        if (note.slide && slideInfo) {
          const prevFreq = this.midiToFrequency(slideInfo.prevPitch);
          this.applySlide(osc, prevFreq, frequency, time);
        }

        // Connect audio graph
        osc.connect(filter);
        filter.connect(vca);
        vca.connect(this.audioContext.destination);

        // Start and stop oscillator
        osc.start(time);
        osc.stop(time + settings.decay + CONSTANTS.OSC_STOP_OFFSET);
      }
    }

    // ============================================================
    // Sequencer: Manages sequence data and operations
    // ============================================================
    class Sequencer {
      constructor() {
        this.sequence = [];
        this.length = CONSTANTS.MAX_STEPS;
        this.currentStep = 0;
        this.initialize();
      }

      initialize() {
        this.generateRandom();
      }

      generateRandom() {
        const newSequence = [];
        let lastActive = false;

        for (let i = 0; i < CONSTANTS.MAX_STEPS; i++) {
          const active = Math.random() < CONSTANTS.NOTE_PROBABILITY;
          const pitch = CONSTANTS.SCALE[Math.floor(Math.random() * CONSTANTS.SCALE.length)];
          const octave = Math.random() < CONSTANTS.OCTAVE_UP_PROBABILITY ? 1 : 0;
          const accent = active && Math.random() < CONSTANTS.ACCENT_PROBABILITY;
          const slide = active && lastActive && Math.random() < CONSTANTS.SLIDE_PROBABILITY;

          newSequence.push({ active, pitch, octave, accent, slide });
          lastActive = active;
        }

        this.sequence = newSequence;
      }

      getNote(index) {
        return this.sequence[index];
      }

      toggleActive(index) {
        this.sequence[index].active = !this.sequence[index].active;
        if (!this.sequence[index].active) {
          this.sequence[index].accent = false;
          this.sequence[index].slide = false;
        }
      }

      toggleAccent(index) {
        if (this.sequence[index].active) {
          this.sequence[index].accent = !this.sequence[index].accent;
        }
      }

      toggleSlide(index) {
        if (this.sequence[index].active) {
          this.sequence[index].slide = !this.sequence[index].slide;
        }
      }

      changePitch(index, direction) {
        if (!this.sequence[index].active) return;

        let combinedPitch = this.sequence[index].pitch + this.sequence[index].octave * 12;
        combinedPitch += direction;
        combinedPitch = Math.max(0, Math.min(CONSTANTS.PITCH_MAX, combinedPitch));

        this.sequence[index].octave = Math.floor(combinedPitch / 12);
        this.sequence[index].pitch = combinedPitch % 12;
      }

      setLength(length) {
        this.length = Math.max(1, Math.min(CONSTANTS.MAX_STEPS, length));
      }

      getLength() {
        return this.length;
      }

      setCurrentStep(step) {
        this.currentStep = step % this.length;
      }

      getCurrentStep() {
        return this.currentStep;
      }

      nextStep() {
        this.currentStep = (this.currentStep + 1) % this.length;
        return this.currentStep;
      }

      reset() {
        this.currentStep = 0;
      }

      getSlideInfo(currentIndex) {
        if (currentIndex === 0) return null;

        const prevIndex = (currentIndex - 1 + this.length) % this.length;
        const prevNote = this.sequence[prevIndex];

        if (!prevNote.active) return null;

        return {
          prevPitch: CONSTANTS.BASE_NOTE + prevNote.octave * 12 + prevNote.pitch
        };
      }
    }

    // ============================================================
    // KnobController: Handles rotary knob interactions
    // ============================================================
    class KnobController {
      constructor(knobElement) {
        this.knob = knobElement;
        this.initialize();
      }

      initialize() {
        this.createValueDisplay();
        this.updateRotation();
        this.knob.addEventListener('input', () => this.updateRotation());
        this.knob.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.knob.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
      }

      createValueDisplay() {
        const display = document.createElement('span');
        display.classList.add('value-display');
        this.valueDisplay = display;
        this.knob.parentElement.appendChild(display);
      }

      updateRotation() {
        const min = parseFloat(this.knob.min);
        const max = parseFloat(this.knob.max);
        const val = parseFloat(this.knob.value);
        const percentage = (val - min) / (max - min);
        const degrees = CONSTANTS.KNOB_ROTATION_MIN + percentage * CONSTANTS.KNOB_ROTATION_RANGE;
        this.knob.style.transform = `rotate(${degrees}deg)`;
        this.updateValueDisplay();
      }

      updateValueDisplay() {
        const value = parseFloat(this.knob.value);
        const id = this.knob.id;

        let text;
        switch(id) {
          case 'cutoff': text = `${Math.round(value)}Hz`; break;
          case 'resonance': text = value.toFixed(1); break;
          case 'envMod': text = `${Math.round(value)}Hz`; break;
          case 'decay': text = `${Math.round(value * 1000)}ms`; break;
          default: text = value.toFixed(1);
        }

        if (this.valueDisplay) {
          this.valueDisplay.textContent = text;
        }
      }

      onMouseDown(e) {
        this.startDrag(e.clientY, e.shiftKey, false);
      }

      onTouchStart(e) {
        const touch = e.touches[0];
        this.startDrag(touch.clientY, false, true);
      }

      startDrag(startY, fineMode, isTouch) {
        const initialValue = parseFloat(this.knob.value);
        const min = parseFloat(this.knob.min);
        const max = parseFloat(this.knob.max);
        const range = max - min;

        const updateValue = (clientY, shiftKey) => {
          const deltaY = startY - clientY;
          const sensitivity = (shiftKey || fineMode)
            ? CONSTANTS.DRAG_SENSITIVITY_FINE
            : CONSTANTS.DRAG_SENSITIVITY_NORMAL;

          let newValue = initialValue + (deltaY / 100) * range * sensitivity;
          newValue = Math.max(min, Math.min(max, newValue));

          this.knob.value = newValue;
          this.knob.dispatchEvent(new Event('input'));
        };

        if (isTouch) {
          const onTouchMove = (e) => {
            if (!e.touches[0]) return;
            updateValue(e.touches[0].clientY, false);
          };
          const onTouchEnd = () => {
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
          };
          document.addEventListener('touchmove', onTouchMove, { passive: false });
          document.addEventListener('touchend', onTouchEnd);
        } else {
          const onMouseMove = (e) => {
            e.preventDefault();
            updateValue(e.clientY, e.shiftKey);
          };
          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          };
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        }
      }
    }

    // ============================================================
    // UIController: Manages all UI elements and interactions
    // ============================================================
    class UIController {
      constructor(sequencer) {
        this.sequencer = sequencer;
        this.elements = this.getElements();
        this.knobControllers = [];
        this.initialize();
      }

      getElements() {
        return {
          sequencerContainer: document.getElementById('sequencer'),
          playStopButton: document.getElementById('play-stop'),
          randomizeButton: document.getElementById('randomize'),
          waveformButton: document.getElementById('waveform'),
          bpmSlider: document.getElementById('bpm'),
          bpmDisplay: document.getElementById('bpm-display'),
          lengthSlider: document.getElementById('length'),
          lengthDisplay: document.getElementById('length-display'),
          cutoff: document.getElementById('cutoff'),
          resonance: document.getElementById('resonance'),
          envMod: document.getElementById('envMod'),
          decay: document.getElementById('decay')
        };
      }

      initialize() {
        this.buildSequencerGrid();
        this.initializeKnobs();
        this.updateSequencerUI();
        this.updateSequencerVisibility();
      }

      buildSequencerGrid() {
        for (let i = 0; i < CONSTANTS.MAX_STEPS; i++) {
          const stepEl = this.createStepElement(i);
          this.elements.sequencerContainer.appendChild(stepEl);
        }
      }

      createStepElement(index) {
        const stepEl = document.createElement('div');
        stepEl.classList.add('step');
        stepEl.dataset.index = index;

        const led = document.createElement('div');
        led.classList.add('led');
        led.addEventListener('click', () => this.onLedClick(index));

        const noteControls = this.createNoteControls(index);

        stepEl.append(led, noteControls);
        return stepEl;
      }

      createNoteControls(index) {
        const container = document.createElement('div');
        container.classList.add('note-controls');

        const upBtn = this.createButton('▲', () => this.onPitchChange(index, 1));
        const downBtn = this.createButton('▼', () => this.onPitchChange(index, -1));
        const accentBtn = this.createButton('A', () => this.onAccentToggle(index));
        const slideBtn = this.createButton('S', () => this.onSlideToggle(index));

        container.append(upBtn, downBtn, accentBtn, slideBtn);
        return container;
      }

      createButton(text, onClick) {
        const btn = document.createElement('button');
        btn.textContent = text;
        btn.addEventListener('click', onClick);
        return btn;
      }

      initializeKnobs() {
        const knobElements = document.querySelectorAll('input.knob');
        knobElements.forEach(knob => {
          this.knobControllers.push(new KnobController(knob));
        });
      }

      onLedClick(index) {
        this.sequencer.toggleActive(index);
        this.updateSequencerUI();
      }

      onPitchChange(index, direction) {
        this.sequencer.changePitch(index, direction);
      }

      onAccentToggle(index) {
        this.sequencer.toggleAccent(index);
        this.updateSequencerUI();
      }

      onSlideToggle(index) {
        this.sequencer.toggleSlide(index);
        this.updateSequencerUI();
      }

      updateSequencerUI() {
        this.sequencer.sequence.forEach((note, i) => {
          const stepEl = this.elements.sequencerContainer.children[i];
          if (!stepEl) return;

          const led = stepEl.querySelector('.led');
          led.classList.toggle('active', note.active);
          led.classList.toggle('accent', note.active && note.accent);

          const accentBtn = stepEl.querySelector('.note-controls button:nth-child(3)');
          accentBtn.classList.toggle('active', note.accent);

          const slideBtn = stepEl.querySelector('.note-controls button:nth-child(4)');
          slideBtn.classList.toggle('active', note.slide);
        });
      }

      updatePlayingLED(index) {
        // Remove playing state from all steps and LEDs
        document.querySelectorAll('.led.playing').forEach(el =>
          el.classList.remove('playing')
        );
        document.querySelectorAll('.step.playing').forEach(el =>
          el.classList.remove('playing')
        );

        // Add playing state to current step
        const stepEl = this.elements.sequencerContainer.children[index];
        if (stepEl) {
          stepEl.classList.add('playing');
          const led = stepEl.querySelector('.led');
          if (led) led.classList.add('playing');
        }
      }

      updateSequencerVisibility() {
        const steps = this.elements.sequencerContainer.children;
        const length = this.sequencer.getLength();

        for (let i = 0; i < CONSTANTS.MAX_STEPS; i++) {
          steps[i].style.display = i < length ? 'flex' : 'none';
        }
      }

      setPlayingState(isPlaying) {
        if (isPlaying) {
          this.elements.playStopButton.textContent = 'Stop';
          this.elements.playStopButton.classList.add('playing');
        } else {
          this.elements.playStopButton.textContent = 'Play';
          this.elements.playStopButton.classList.remove('playing');
          document.querySelectorAll('.led.playing').forEach(el =>
            el.classList.remove('playing')
          );
          document.querySelectorAll('.step.playing').forEach(el =>
            el.classList.remove('playing')
          );
        }
      }

      getSettings() {
        return {
          waveform: this.elements.waveformButton.textContent,
          cutoff: parseFloat(this.elements.cutoff.value),
          resonance: parseFloat(this.elements.resonance.value),
          envMod: parseFloat(this.elements.envMod.value),
          decay: parseFloat(this.elements.decay.value),
          bpm: parseFloat(this.elements.bpmSlider.value)
        };
      }

      getBPM() {
        return parseFloat(this.elements.bpmSlider.value);
      }
    }

    // ============================================================
    // FilterVisualizer: Displays filter frequency response
    // ============================================================
    class FilterVisualizer {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) return;
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
      }

      draw(cutoff, resonance) {
        if (!this.ctx) return;

        // Clear
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Grid
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < this.height; i += 10) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, i);
          this.ctx.lineTo(this.width, i);
          this.ctx.stroke();
        }

        // Draw filter response curve
        this.ctx.strokeStyle = '#0f0';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();

        for (let x = 0; x < this.width; x++) {
          const freq = (x / this.width) * 12000; // 0-12kHz
          const response = this.calculateFilterResponse(freq, cutoff, resonance);
          const y = this.height - (response * this.height * 0.9) - 2;

          if (x === 0) {
            this.ctx.moveTo(x, y);
          } else {
            this.ctx.lineTo(x, y);
          }
        }
        this.ctx.stroke();

        // Cutoff frequency marker
        const cutoffX = (cutoff / 12000) * this.width;
        this.ctx.strokeStyle = '#ff6a00';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([2, 2]);
        this.ctx.beginPath();
        this.ctx.moveTo(cutoffX, 0);
        this.ctx.lineTo(cutoffX, this.height);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
      }

      calculateFilterResponse(freq, cutoff, resonance) {
        const ratio = freq / cutoff;
        const qFactor = resonance / 10;

        if (ratio < 1) {
          // Resonance peak before cutoff
          return Math.min(1 + (qFactor * 0.15 * (1 - ratio * 0.5)), 1.5);
        } else {
          // Roll-off after cutoff (-12dB/oct)
          return 1 / (1 + Math.pow(ratio, 1.5));
        }
      }
    }

    // ============================================================
    // EnvelopeVisualizer: Displays envelope decay curve
    // ============================================================
    class EnvelopeVisualizer {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) return;
        this.ctx = this.canvas.getContext('2d');
        this.width = this.canvas.width;
        this.height = this.canvas.height;
      }

      draw(decayTime, envMod) {
        if (!this.ctx) return;

        // Clear
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Grid
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < this.height; i += 10) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, i);
          this.ctx.lineTo(this.width, i);
          this.ctx.stroke();
        }

        // Filter envelope (orange)
        this.ctx.strokeStyle = '#ff6a00';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();

        const maxTime = 1.0; // Display up to 1 second
        for (let x = 0; x < this.width; x++) {
          const time = (x / this.width) * maxTime;
          let amplitude;

          if (time < decayTime * 1.2) {
            amplitude = 1 - (time / (decayTime * 1.2));
          } else {
            amplitude = 0;
          }

          const y = this.height - (amplitude * this.height * 0.9) - 2;
          if (x === 0) {
            this.ctx.moveTo(x, y);
          } else {
            this.ctx.lineTo(x, y);
          }
        }
        this.ctx.stroke();

        // VCA envelope (yellow)
        this.ctx.strokeStyle = '#ffd700';
        this.ctx.lineWidth = 1.5;
        this.ctx.beginPath();

        for (let x = 0; x < this.width; x++) {
          const time = (x / this.width) * maxTime;
          let amplitude;

          if (time < decayTime) {
            amplitude = 1 - (time / decayTime);
          } else {
            amplitude = 0;
          }

          const y = this.height - (amplitude * this.height * 0.7) - 2;
          if (x === 0) {
            this.ctx.moveTo(x, y);
          } else {
            this.ctx.lineTo(x, y);
          }
        }
        this.ctx.stroke();
      }
    }

    // ============================================================
    // TB303Synth: Main controller coordinating all components
    // ============================================================
    class TB303Synth {
      constructor() {
        this.audioEngine = new AudioEngine();
        this.sequencer = new Sequencer();
        this.uiController = new UIController(this.sequencer);
        this.filterVisualizer = new FilterVisualizer('filter-canvas');
        this.envelopeVisualizer = new EnvelopeVisualizer('envelope-canvas');
        this.isPlaying = false;
        this.nextNoteTime = 0;
        this.timerID = null;
        this.bindEvents();
        this.updateVisualizers();
      }

      bindEvents() {
        const ui = this.uiController.elements;

        ui.playStopButton.addEventListener('click', () => this.togglePlayback());
        ui.randomizeButton.addEventListener('click', () => this.randomize());

        ui.waveformButton.addEventListener('click', () => {
          ui.waveformButton.textContent =
            ui.waveformButton.textContent === 'SAW' ? 'SQUARE' : 'SAW';
        });

        ui.bpmSlider.addEventListener('input', (e) => {
          ui.bpmDisplay.textContent = e.target.value;
        });

        ui.lengthSlider.addEventListener('input', (e) => {
          const length = parseInt(e.target.value, 10);
          this.sequencer.setLength(length);
          ui.lengthDisplay.textContent = length;
          this.uiController.updateSequencerVisibility();

          if (this.isPlaying && this.sequencer.getCurrentStep() >= length) {
            this.sequencer.reset();
          }
        });

        // Update visualizers when knobs change
        ui.cutoff.addEventListener('input', () => this.updateVisualizers());
        ui.resonance.addEventListener('input', () => this.updateVisualizers());
        ui.envMod.addEventListener('input', () => this.updateVisualizers());
        ui.decay.addEventListener('input', () => this.updateVisualizers());
      }

      updateVisualizers() {
        const settings = this.uiController.getSettings();
        this.filterVisualizer.draw(settings.cutoff, settings.resonance);
        this.envelopeVisualizer.draw(settings.decay, settings.envMod);
      }

      togglePlayback() {
        this.audioEngine.initialize();
        this.isPlaying = !this.isPlaying;

        if (this.isPlaying) {
          this.startPlayback();
        } else {
          this.stopPlayback();
        }

        this.uiController.setPlayingState(this.isPlaying);
      }

      startPlayback() {
        this.sequencer.reset();
        this.nextNoteTime = this.audioEngine.getContext().currentTime;
        this.scheduler();
      }

      stopPlayback() {
        if (this.timerID) {
          clearTimeout(this.timerID);
          this.timerID = null;
        }
      }

      scheduler() {
        const ctx = this.audioEngine.getContext();

        while (this.nextNoteTime < ctx.currentTime + CONSTANTS.SCHEDULE_AHEAD_TIME) {
          this.scheduleNote(this.nextNoteTime);
          this.advanceStep();
        }

        this.timerID = setTimeout(() => this.scheduler(), CONSTANTS.SCHEDULER_INTERVAL);
      }

      scheduleNote(time) {
        const currentStep = this.sequencer.getCurrentStep();
        const note = this.sequencer.getNote(currentStep);
        const settings = this.uiController.getSettings();

        let slideInfo = null;
        if (note.slide) {
          slideInfo = this.sequencer.getSlideInfo(currentStep);
        }

        this.audioEngine.playNote(note, settings, time, slideInfo);
        this.uiController.updatePlayingLED(currentStep);
      }

      advanceStep() {
        const secondsPerBeat = 60.0 / this.uiController.getBPM();
        this.nextNoteTime += CONSTANTS.SIXTEENTH_NOTE_MULTIPLIER * secondsPerBeat;
        this.sequencer.nextStep();
      }

      randomize() {
        this.sequencer.generateRandom();
        this.uiController.updateSequencerUI();
      }
    }

    // ============================================================
    // Initialize application
    // ============================================================
    document.addEventListener('DOMContentLoaded', () => {
      new TB303Synth();
    });
  </script>
</body>
</html>
